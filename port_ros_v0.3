#include "ros/ros.h"
#include "std_msgs/String.h"

#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <errno.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <termios.h>
#include <stdlib.h>
#include <unistd.h>
#include "sensor_msgs/LaserScan.h"

class Controller{
    public:
    int fd;
    int i;
    char sendbuff[20] = "hahaha\r\n";
    int set_opt(int fd,int nSpeed, int nBits, char nEvent, int nStop);
    int open_port(int fd,int comport);
    static void chatterCallback(const std_msgs::String::ConstPtr& msg);
    void connectPort();
    Controller(){
        int nread,nwrite;
        char  buff[512];
        std_msgs::String msg;
        ros::NodeHandle n;
        ros::Rate loop_rate(5);
        sub = n.subscribe("chatter", 10, &chatterCallback);
        cmd_pub = n.advertise<std_msgs::String>("command", 5);
	connectPort();
        while (ros::ok()) //循环读取数据
        {
            while((nread = read(fd, buff, 512))>0)		//read from st
            {
                printf( "%s", buff);
            std::string str(buff);
            msg.data = str;
                memset( buff, 0, 512 );
                nwrite = write(fd, sendbuff, strlen(sendbuff));	//write to st
            cmd_pub.publish(msg);				//publish info to the "command" topic
                ros::spinOnce();					//subscribe info is triggerred in callback
                loop_rate.sleep();		//0.1s
            }
        }
	close(fd);
    }


    private:

    ros::Subscriber sub;
    ros::Publisher cmd_pub;
};

int Controller::set_opt(int fd,int nSpeed, int nBits, char nEvent, int nStop)
{
    struct termios newtio,oldtio;
    if  ( tcgetattr( fd,&oldtio)  !=  0)
    {
        perror("SetupSerial 1");
        return -1;
    }
    bzero( &newtio, sizeof( newtio ) );
    newtio.c_cflag  |=  CLOCAL | CREAD;
    newtio.c_cflag &= ~CSIZE;

    switch( nBits )
    {
    case 7:
        newtio.c_cflag |= CS7;
        break;
    case 8:
        newtio.c_cflag |= CS8;
        break;
    }

    switch( nEvent )
    {
    case 'O':                     //奇校验
        newtio.c_cflag |= PARENB;
        newtio.c_cflag |= PARODD;
        newtio.c_iflag |= (INPCK | ISTRIP);
        break;
    case 'E':                     //偶校验
        newtio.c_iflag |= (INPCK | ISTRIP);
        newtio.c_cflag |= PARENB;
        newtio.c_cflag &= ~PARODD;
        break;
    case 'N':                    //无校验
        newtio.c_cflag &= ~PARENB;
        break;
    }

switch( nSpeed )
    {
    case 2400:
        cfsetispeed(&newtio, B2400);
        cfsetospeed(&newtio, B2400);
        break;
    case 4800:
        cfsetispeed(&newtio, B4800);
        cfsetospeed(&newtio, B4800);
        break;
    case 9600:
        cfsetispeed(&newtio, B9600);
        cfsetospeed(&newtio, B9600);
        break;
    case 115200:
        cfsetispeed(&newtio, B115200);
        cfsetospeed(&newtio, B115200);
        break;
    default:
        cfsetispeed(&newtio, B9600);
        cfsetospeed(&newtio, B9600);
        break;
    }
    if( nStop == 1 )
    {
        newtio.c_cflag &=  ~CSTOPB;
    }
    else if ( nStop == 2 )
    {
        newtio.c_cflag |=  CSTOPB;
    }
    newtio.c_cc[VTIME]  = 0;
    newtio.c_cc[VMIN] = 0;
    tcflush(fd,TCIFLUSH);
    if((tcsetattr(fd,TCSANOW,&newtio))!=0)
    {
        perror("com set error");
        return -1;
    }
    printf("set done!\n");
    return 0;
}

int Controller::open_port(int fd,int comport)
{
    //char *dev[]={"/dev/ttyACM0","/dev/ttyUSB0","/dev/ttyS2"};
    //long  vdisable;
    if (comport==1)
    {    fd = open( "/dev/ttyACM0", O_RDWR|O_NOCTTY|O_NDELAY);
        if (-1 == fd)
        {
            perror("Can't Open Serial Port");
            return(-1);
        }
        else
        {
            printf("open ttyACM .....\n");
        }
    }
    else if(comport==2)
    {    fd = open( "/dev/ttyUSB0", O_RDWR|O_NOCTTY|O_NDELAY);
        if (-1 == fd)
        {
            perror("Can't Open Serial Port");
            return(-1);
        }
        else
        {
            printf("open ttyS1 .....\n");
        }
    }
    else if (comport==3)
    {
        fd = open( "/dev/ttyS2", O_RDWR|O_NOCTTY|O_NDELAY);
        if (-1 == fd)
        {
            perror("Can't Open Serial Port");
            return(-1);
        }
        else
        {
            printf("open ttyS2 .....\n");
        }
    }
    if(fcntl(fd, F_SETFL, FNDELAY)<0)
    {
        printf("fcntl failed!\n");
    }
    else
    {
        printf("fcntl=%d\n",fcntl(fd, F_SETFL,FNDELAY));
    }
    if(isatty(STDIN_FILENO)==0)
    {
        printf("standard input is not a terminal device\n");
    }
    else
    {
        printf("isatty success!\n");
    }
    printf("fd-open=%d\n",fd);
    return fd;
}

void Controller::chatterCallback(const std_msgs::String::ConstPtr& msg)
{
  ROS_INFO("I heard: [%s]", msg->data.c_str());
  //write(fd, msg->data.c_str(), strlen(msg->data.c_str()));
}

void Controller::connectPort(){
    if((fd=open_port(fd,1))<0)
    {
        perror("open_port error");
        return;
    }
    if((i=set_opt(fd,115200,8,'N',1))<0)
    {
        perror("set_opt error");
        return;
    }
    printf("fd=%d\n",fd);
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "listener");
    Controller C;
    return 0;
}

